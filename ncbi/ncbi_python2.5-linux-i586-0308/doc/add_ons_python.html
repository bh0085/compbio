<html>
<head>
</head>

<body>

<h2>Add-On Functionality in the
Python 
Interface</h2>

The Python interface
to the NCBI C++ Toolkit contains some "add-on" funtionality: functions
and classes that are not present in the Toolkit.
Some of these are aimed at
interactive users of the wrappers.  Some provide simpler
or more Pythonic
ways of doing things.  Some provide or mimic C++ language
features that would otherwise be inaccessible from
Python.
These functions and classes are documented below.
<p>
Several of these functions display web pages using web browsers.
They do this using the Python
<a href="http://docs.python.org/lib/module-webbrowser.html">webbrowser</a>
module.  
This module is sensitive to the BROWSER environment variable, which
you can set to change the browser "try order" if the default is not
to your liking, as described
<a href="http://docs.python.org/lib/module-webbrowser.html">here</a>.

<h3>Access to Toolkit Documentation and Information</h3>

Automatically-generated documentation for the Toolkit is
available on the web.  The ASN.1 specifications for NCBI
data model objects are another important source of information
and can be regarded as documentation for the classes that
represent them.  Several functions provide easy acces
to these resources.
<p>
<h4>Doxy()</h4>

Examples:


<font color="brown"><pre>
loc = ncbi.CSeq_loc()
loc.Doxy()
ncbi.CSeq_loc.Doxy()
ncbi.Doxy('CSeq_loc')
ncbi.Doxy(loc)
ncbi.Doxy(ncbi.CSeq_loc)
</pre></font>




All of the above <code>Doxy()</code> calls accomplish the same thing: bring up
the <a href="http://www.doxygen.org/index.html">doxygen</a>-generated
documentation web page for class CSeq_loc.  <code>Doxy()</code>
is most commonly called on a class or on an object of the class,
as in the first two calls above.
<p>
This documentation is an extremely useful source of information about
the Toolkit.  I hope that easy access through <code>Doxy()</code> will
encourage its use by users of the wrappers.  Note that the
web pages reflect a recent internal version of the Toolkit,
which might differ slightly from the version used to build
the wrappers.  Also keep in mind that members of
a class may be inherited from superclasses, so you will sometimes have
to click on superclasses to get important information.
A particular example is serial objects,such as
<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__loc.html style=text-decoration:none>CSeq_loc</a>, for which
all of the member-access functions that are generated automatically
from the ASN.1 specification reside in a base class
(<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__loc__Base.html style=text-decoration:none>CSeq_loc_Base</a> in this example).



<p>
<h4>Lxr()</h4>

Examples:


<font color="brown"><pre>
loc.Lxr()
ncbi.CSeq_loc.Lxr()
ncbi.Lxr('AgpRead')
etc.
</pre></font>




Similar to <code>Doxy()</code>,
but it launches documentation generated by 
<a href="http://lxr.linux.no">LXR</a>
rather than doxygen.  This lacks many of the niceties
of the doxygen-generated documentation, but <code>Lxr()</code> can be
used to get at information about
functions and other entitities in addition to classes, as in the
<code>AgpRead</code> example above.

<p>
<h4>Spec()</h4>

Examples:


<font color="brown"><pre>
loc.Spec()
loc.Spec(1)
ncbi.CSeq_loc.Spec()
ncbi.CSeq_loc.Spec(1)
ncbi.Spec('Seq-loc')
ncbi.Spec('Seq-loc', 1)
</pre></font>




<code>Spec()</code> provides access to the
ASN.1 specification that defines
an NCBI data model type.  The forms without a '1' argument
print the specification to the screen.  The forms with the additional
'1' argument (any "true" argument will work) instead bring up a web
page with the specification.  The web pages contain links to other
ASN.1 types referenced in the specification, to the entire file
that contains the specification, and to the C++ class representing
this type, if there is one.  The <code>Spec()</code> method is restricted to
serial objects
(<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSerialObject.html style=text-decoration:none>CSerialObject</a> and subclasses),
since other classes do not have corresponding ASN.1 specifications.

<h3>Entrez Display</h3>
Many users are familiar with access to NCBI's data through the
Entrez web interface.  These functions provide a way of
displaying a set of sequences, PubMed articles, or items from
any other Entrez database on a web page.
This is a convenient way of
presenting a list of items in human-browsable form.
<p>
<h4>EntrezWeb() and EntrezUrl()</h4>

Examples:


<font color="brown"><pre>
ncbi.EntrezWeb('NC_000001')                                # human chr. 1
ncbi.EntrezWeb(['NC_0000%.2d' % i for i in range(1, 25)])  # all human chrs.
ncbi.EntrezWeb([833605, 658638], 'gene')
url = ncbi.EntrezUrl(...)
</pre></font>




<code>EntrezWeb()</code> launches an Entrez web page for a
list of identifiers for any Entrez database.
<code>EntrezUrl()</code> returns a url for such a page,
so that you may incorporate it as a link into your own web pages.
The arguments to the two functions are the same.
<p>
The first argument is either a single identifier or
some kind of list of identifiers.
For sequence databases, the identifiers can take several forms:
an integer (gi), a string representation of an identifier (such
as an accession), or a <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__id.html style=text-decoration:none>CSeq_id</a> object.
For other Entrez databases
an identifier must be an integer unique identifier (UID).
A list of identifiers can take the form of a
Python list or tuple
 
or a wrapped C++ vector or list.
<p>
The second argument is a string that names the Entrez database.  For
sequences this can be omitted; the function will use the first identifier
to decide whether the 'nucleotide' or 'protein' database is appropriate.
<p>
Use of these functions should be restricted to relatively small numbers
of identifiers, with a limit of about 1000.
Otherwise the url becomes too long and the web server
will not handle it.  Furthermore, some browsers impose even lower
ceilings on url length.

<h3>Serial Object Extensions</h3>

Serial objects (<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSerialObject.html style=text-decoration:none>CSerialObject</a>
and its many subclasses) constitute
a significant fraction of the classes in the Toolkit.  They mostly
represent datatypes that are defined by ASN.1 specifications.
These additional methods, not present in C++, facilitate
working with serial objects.

<p>
<h4>CSerialObject.Clone()</h4>

Example:


<font color="brown"><pre>
loc_orig = ncbi.CSeq_loc()
...
loc_copy = loc.Clone()
</pre></font>




In Python, CSerialObject
is equipped with a <code>Clone()</code> method that returns
a deep copy of the object.
This is useful because serial objects lack copy constructors.
This is a convenience function that creates a new object and
uses <code>Assign()</code> to turn it into a copy of the original object.


<p>
<h4>CSerialObject.TextView() and CSerialObject.TextEdit()</h4>

Examples:


<font color="brown"><pre>
id = ncbi.CSeq_id('NC_000022.8')
id.TextView()
id2 = id.TextEdit()
</pre></font>




<code>TextView()</code> launches a text editor containing an ASN.1 text
representation of the object.  If the editor is know to be
backgroundable (see below), it is launched in the background, so that
work at an interactive prompt can continue while the ASN.1
remains displayed.
<p>
<code>TextEdit()</code> launches an editor with the ASN.1 text in the
foreground.  After editing is complete, it captures the edited
text and attempts to build a new object by parsing it.  The
new object is returned.  If the edited text is not valid ASN.1
for the data type, an exception is thrown.  Note
that in this case edits are lost.
<p>
These functions use the contents of the VISUAL environment
variable, if set, as the editor.  If that is not set,
the EDITOR enviroment variable is used if it is set.
If neither is set, the functions fall back on "vi".
Editors known to the functions to be "backgroundable"
are emacs, xemacs, emacsclient, and nedit.  Backgrounding
is done only if the DISPLAY environment variable is set.

<h3>Type Casting</h3>

These functions perform casting operations similar to
C++ casts of pointers.  It is anticipated that these
functions will be used infrequently, but will occasionally
be useful, like their C++ counterparts.

<p>
<h4>dynamic_cast()</h4>

Examples:


<font color="brown"><pre>
loc = ncbi.CSeq_loc()
obj = ncbi.dynamic_cast(ncbi.CObject, loc)         # Not so useful to cast up
loc2 = ncbi.dynamic_cast(ncbi.CSeq_loc, obj)       # Downcast; sometimes useful
sobj = ncbi.dynamic_cast(ncbi.CSerialObject, obj)  # Also succeeds
id = ncbi.dynamic_cast(ncbi.CSeq_id, obj)          # Fails; id == None
</pre></font>




C++ dynamic_cast, which allows "safe" downcasting (the result indicates
whether the object is really of an appropriate type), is supported
to a limited extent in the wrappers.  It works for
<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCObject.html style=text-decoration:none>CObject</a> and derived classes,
which include CSerialObject and its subclasses, and for type information
classes (<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCTypeInfo.html style=text-decoration:none>CTypeInfo</a> subclasses).
CObject subclasses constitute
over half the classes in the wrappers, and a larger fraction of the
polymorphic classes, so this is significant coverage.
<p>
The first argument to <code>dynamic_cast</code> is the class to be cast to.
The second is the thing to be cast.  If the dynamic type of
the object being cast is the destination class or a subclass,
the result will be a proxy object of the destination class.
Otherwise the cast fails and the result is
None.  In this
sense <code>dynamic_cast</code> in
Python
is similar to <code>dynamic_cast</code> of a pointer
in C++, as opposed to <code>dynamic_cast</code> of a reference, which throws
an exception upon failure.



<p>
<h4>Downcast()</h4>

Example:
<font color="brown"><pre>
cast_obj = ncbi.Downcast(obj)  # With obj from above, cast_obj is a CSeq_loc
</pre></font>

Applied to an object for which <code>dynamic_cast</code> is supported,
<code>Downcast</code> will
return the object cast "all the way down" to its "real" dynamic type.
This is accomplished by trying, in turn, to dynamic_cast to all of the
classes derived directly from the original class until one succeeds,
and applying this procedure recursively to the result, until no
further down-casting is possible.  This procedure can be slow,
and a program using it would likely need class-specific logic
anyway (which could have used dynamic_cast),
so <code>Downcast()</code> is probably most useful
in exploration of the Toolkit
as a convenient way of determining the dynamic type of a returned object.

<p>
<h4>DownCastSerialObject()</h4>

Example:
<font color="brown"><pre>
foo = ncbi.DowncastSerialObject(obj)
</pre></font>

Similar do <code>Downcast()</code>, but it only works on serial objects, and
is usually significantly faster.  It uses the serial object type
information system to determine the type of the object, thus
avoiding having to try the possibilities in succession.




<p>
<a name="reinterpret_cast"><h4>reinterpret_cast()</h4></a>

Example:


<font color="brown"><pre>
cptr = ncbi.reinterpret_cast('_p_char', iptr)                   # cast to pointer to char
loc = ncbi.reinterpret_cast('_p_ncbi__objects__CSeq_loc', obj)  # cast to CSeq_loc
</pre></font>




The Python
<code>reinterpret_cast</code>
function, like its C++ counterpart, is meant to be used as a last resort
when one type must be coerced into another.
The Python function does not
call the C++ cast operator.  Rather, it manipulates the wrapper's
representation of a pointer to give it a different type.  It will likely find
use mostly for pointers for built-in types.  It can be used to cast between
different classes, but, like its C++ analog, it may give incorrect results
in cases involving multiple inheritance, even for types related by inheritance.
<code>dynamic_cast</code> is a much better choice in cases where it applies.
<p>
The following code uses <code>reinterpret_cast</code>
to cast from a pointer to
<code>unsigned char</code> to a pointer to <code>char</code>.
This allows
the data in a <code>vector&lt;unsigned char&gt;</code>
to be passed as an argument
to a function that requires a <code>char</code> pointer,
namely to a <code>std::string</code> constructor.
Intermediate variables are
assigned and printed for purposes of illustration; the string
construction could be done in one line once the vector
is construced.


<font color="brown"><pre>
vec = ncbi.vector_unsigned_char([102, 111, 111])  # ASCII values of 'f', 'o', and 'o'
uc_ptr = vec.data()
print uc_ptr
<em>&lt;Swig Object at _18687408_p_unsigned_char&gt;</em>
c_ptr = ncbi.reinterpret_cast('_p_char', uc_ptr)
print c_ptr
<em>&lt;Swig Object at _18687408_p_char&gt;</em>
s = ncbi.string(c_ptr, 3)                         # Passing uc_ptr here would fail
print s
<em>foo</em>
</pre></font>




<h3>Pointers to Built-in Types</h3>

Several add-on features in the wrapper facilitate the handling
and creation of pointers to built-in types (integral types, characters,
floating point types, and booleans).  Functions
<code>deref()</code>, <code>defer_assign()</code>, and
<code>array_assign()</code> allow reading and writing the
values at which a pointer points.  Function <code>Array()</code>
and the associated classes provide an array-like interface
for the same purpose.  Classes
<code>int_p</code>, <code>double_p</code>, <code>unsigned_char_p</code>,
etc., allocate an element of the appropriate type and act as pointers
to that type for the purpose of argument passing.  For
every built-in type other than <code>bool</code>,
<code>std::vector</code> is augmented with a <code>data()</code>
method that returns a pointer to its internal array (the address
of its first element).  These functions and classes are
described in more detail in the section on
<a href="pointers_and_refs_python.html">
Dealing with Pointers and References to Built-in Types in
Python</a>



<h3>Module Inspection</h3>

In Python, entities such as classes, functions, and modules are objects
and can be examined and computed on by Python code.  The Toolkit
wrapper takes advantage of this to provide some useful functions
and support the writing of others.

<p>
<h4>Search()</h4>

Examples:

<font color="brown"><pre>
ncbi.Search('fasta')      # Find top-level things containing 'fasta', case-insensitively
ncbi.Search('fasta', 1)   # Also find class members containing 'fasta'
ncbi.Search('_CI$')       # Find top-level things ending in '_ci' (case-insensitively)
</pre></font>

<code>Search()</code> searches the Toolkit module for
entities whose names match a pattern,
then prints the results to the screen.
It does a case-insensitive regular expression search, using the
<a href="http://docs.python.org/lib/module-re.html">Python <code>re</code> module</a>,
and hence its syntax.  By default, class members
are not searched.  Adding a second parameter that is 
considered "True", such as 1,
includes class members in the search.  Note that a class member's name must
match by itself to be considered a match, as must a class's name; the regular
expression is not applied to a qualified name like "CFoo.Bar", but to
"CFoo" and "Bar" separately.

<p>
<h4>info()</h4>

Examples:

<font color="brown"><pre>
ncbi.info()
ncbi.info(1)
</pre></font>

Function <code>info()</code>, invoked with no arguments,
prints some information about the
number of various types of entities in the module.  Invoked with a single
"True" argument, it augments this with a breakdown of serial objects by
the ASN.1 module in which they were defined.

<p>
<h4>classes()</h4>

Example:

<font color="brown"><pre>
cls = ncbi.classes()                     # Get the classes
len([cl for cl in cls.values()
     if issubclass(cl, ncbi.CObject)])   # count CObject subclasses
</pre></font>

<code>classes()</code> returns a dictionary with one entry
for each proxy class in
the module.  The dictionary key is the class name and the
corresponding value is the class itself.
This result can be used, along with Python funtionality
such as <code>issubclass()</code> and features of new-style classes,
to extract information about the classes and their inheritance hierarchy.
The code below, for example, uses the result of <code>classes()</code>
to find all cases of multiple inheritance and print each multiply
inheriting class and its base classes.

<font color="brown"><pre>
cls = ncbi.classes()
for clname in cls:
    bases = [base.__name__ for base in cls[clname].__bases__]
    if len(bases) > 1:
        print '%-29s%s' % (clname, bases)
</pre></font>




<p>
<!-- Begin footer content -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT>
<a NAME="copyright"></a>
<address>
<a href="mailto:jcherry@ncbi.nlm.nih.gov">Josh Cherry</a>&nbsp;</address>
</td>

<td>


</tr>
</table>

</body>

</html>
