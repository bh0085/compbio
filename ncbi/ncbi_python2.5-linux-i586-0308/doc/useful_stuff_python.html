<html>
<head>
</head>

<body>

<h2>Doing Some Useful Things with the
Python 
Interfaces to the NCBI C++ Toolkit</h2>

<h3>Introduction</h3>

This document illustrates the use of the
Python interface
to the
<a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">NCBI C++ Toolkit</a>
to do some things that come up frequently in biological applications.
It builds on the information in
<a href="python_basic.html">Getting started with the Python module</a>

and <a href="cpp_details.html">Details of C++/scripting language mappings</a>.

<p>
Although it contains some important <a href="add_ons_python.html">extensions</a>, the
Python interface
mainly mirrors the underlying C++ Toolkit.
The Toolkit is a vast topic; the
Python interface
wraps over 3000 classes and a few hundred free-standing functions.
This document can only scratch the surface of the Toolkit.
Its intent is to introduce some of the classes and functions
that are most central or useful,
and to use these to illustrate
the use of the Toolkit from
Python.
Much more information can be found in the
<a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">NCBI C++ Toolkit Book</a>,
the <a href="http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/index.html">
Doxygen-generated documentation</a>,
and the <a href="http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/">
ASN.1 specifications</a> for serial datatypes.  Many links to this
documentation are provided in what follows.  As explained
<a href="python_basic.html">here</a>
,
the Python interface
also provides convenient access to much of this documentation
through the <code><font color="brown">Doxy</font></code> and 
<code><font color="brown">Spec</font></code> methods
and functions.  If you have an object whose class you would like to know more
about, don't hesitate to call its <code><font color="brown">Doxy</font></code>
method and, if it's a serial object,
its <code><font color="brown">Spec</font></code> method.

<p>
In what follows, Python
code is shown in an upright font
<code><font color="brown">like this</font></code>
and output from the interpreter is shown in italics
<code><font color="brown"><em>like this</em></font></code>.


You should be able to execute all of the example code
at an interactive Python prompt or from a file
(but don't forget to <code><font color="brown">import ncbi</font></code>).
The ouput shown is what you would see in an interactive session;
some of the output would be omitted if the code were executed from a
file, but could be restored with
<code><font color="brown">print</font></code> statements.




Note that some of the example code relies on
variables defined by execution of earlier examples.


<h3>Sequence Identifiers: <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-id.html style=text-decoration:none>Seq-id</a>/<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__id.html style=text-decoration:none>CSeq_id</a></h3>
Sequences are often referred to by identifiers.  These
will be familiar to many users in their string or
integer (gi) forms, e.g., NC_000022.7, 51511751, NM_007207, L09137.
The ASN.1 type <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-id.html style=text-decoration:none>Seq-id</a>, and the corresponding class
<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__id.html style=text-decoration:none>CSeq_id</a>,
represent these in a more structured form, but can be constructed
from strings such as the above:

<font color="brown"><pre>
id = ncbi.CSeq_id('NC_000022.7')
print id.Asn()
<em>Seq-id ::= other {
  accession "NC_000022",
  version 7
}</em>
</pre></font>




The string must be recognizable as some format that the class
knows about; otherwise an exception will be thrown.
If you want to construct a CSeq_id for an arbitrary string
that may have meaning only to you, you can make a local id:

<font color="brown"><pre>
local_id = ncbi.CSeq_id('lcl|my_id_string')
</pre></font>



The fields of the Seq-id can be accessed like those of
any serial object, e.g.,

<font color="brown"><pre>
id.GetOther().GetVersion()
<em>7</em>
</pre></font>



Methods also exist for obtaining a string representation of the
id:

<font color="brown"><pre>
id.GetSeqIdString()
<em>'NC_000022'</em>
id.GetSeqIdString(True)
<em>'NC_000022.7'</em>
id.AsFastaString()
<em>'ref|NC_000022.7|'</em>
</pre></font>




<h3>Sequence Locations: <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-loc.html style=text-decoration:none>Seq-loc</a>/<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__loc.html style=text-decoration:none>CSeq_loc</a></h3>
Locations on biological sequences are represented
by the ASN.1 type <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-loc.html style=text-decoration:none>Seq-loc</a> and the corresponding class
<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__loc.html style=text-decoration:none>CSeq_loc</a>.
In the simplest cases a location is
a point or interval on a single sequence, but it
can be much more complex.  For example, the location
of a coding region on a chromosome will usually consist of
a series of intervals in organisms where introns are common.

<p>
As can be seen from its ASN.1 specification, a Seq-loc
is an ASN.1 "choice" of several possibilities:

<font color="brown"><pre>
ncbi.Spec('Seq-loc')
<em>Seq-loc ::= CHOICE {
    null NULL ,           -- not placed
    empty Seq-id ,        -- to NULL one Seq-id in a collection
    whole Seq-id ,        -- whole sequence
    int Seq-interval ,    -- from to
    packed-int Packed-seqint ,
    pnt Seq-point ,
    packed-pnt Packed-seqpnt ,
    mix Seq-loc-mix ,
    equiv Seq-loc-equiv ,  -- equivalent sets of locations
    bond Seq-bond ,
    feat Feat-id }         -- indirect, through a Seq-feat</em>
</pre></font>


The most commonly encountered types of Seq-locs are discussed next.

<p>
One basic type of location is an interval (<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-interval.html style=text-decoration:none>Seq-interval</a>).
This consists of a Seq-id, "from" and "to" positions,
and optionally a strand designation and some other,
less commonly used attributes (see the ASN.1 specification
for <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-interval.html style=text-decoration:none>Seq-interval</a>).  Such locations can
be built as follows:

<font color="brown"><pre>
loc = ncbi.CSeq_loc()
loc.SetInt().SetId(ncbi.CSeq_id('L09137'))
loc.SetInt().SetFrom(100)                 
loc.SetInt().SetTo(200)
print loc.Asn()
<em>Seq-loc ::= int {
  from 100,
  to 200,
  id genbank {
    accession "L09137"
  }
}</em>

another_loc = ncbi.CSeq_loc()
another_loc.SetInt().SetId(id)
another_loc.SetInt().SetFrom(20000000)
another_loc.SetInt().SetTo(20000100)
another_loc.SetInt().SetStrand(ncbi.eNa_strand_minus)
print another_loc.Asn()
<em>Seq-loc ::= int {
  from 20000000,
  to 20000100,
  strand minus,
  id other {
    accession "NC_000022",
    version 7
  }
}</em>
</pre></font>




Sequence coordinates are "zero-based": the index of the
first residue in a sequence is zero, not one.  This convention
is observed throughout the Toolkit, and is compatible with
string and array indexing in C++, Python, and Perl,
but is different from what will be found in genbank
flat file format or human-readable BLAST output.

<p>
Another basic type of location is a <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-point.html style=text-decoration:none>Seq-point</a>:

<font color="brown"><pre>
pnt_loc = ncbi.CSeq_loc()
pnt_loc.SetPnt().SetId(id)
pnt_loc.SetPnt().SetPoint(42)
</pre></font>



<p>
A <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-loc-mix.html style=text-decoration:none>Seq-loc-mix</a> is an arbitrary collection of Seq-locs:

<font color="brown"><pre>
mix_loc = ncbi.CSeq_loc()
mix = mix_loc.SetMix()
mix.Set().append(loc)
mix.Set().append(pnt_loc)
mix.Set().append(another_loc)
print mix.Asn()
<em>Seq-loc-mix ::= {
  int {
    from 100,
    to 200,
    id genbank {
      accession "L09137"
    }
  },
  pnt {
    point 42,
    id other {
      accession "NC_000022",
      version 7
    }
  },
  int {
    from 20000000,
    to 20000100,
    strand minus,
    id other {
      accession "NC_000022",
      version 7
    }
  }
}</em>
</pre></font>




An element of a mix can be any type of Seq-loc, including
a mix.

<p>
<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Packed-seqint.html style=text-decoration:none>Packed-seqint</a>
and <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Packed-seqpnt.html style=text-decoration:none>Packed-seqpnt</a>
are compact ways of
representing series of intervals or points.  The
first of these is often used to represent a
transcript or coding region that includes multiple
exons (a mix is another possibility for that).

<p>
A location can also be set to represent a whole
sequence.  This is convenient when a function
(for example, various BLAST functions)
takes a Seq-loc but it is desirable to analyze an
entire sequence:

<font color="brown"><pre>
whole = ncbi.CSeq_loc()
whole.SetWhole(ncbi.CSeq_id('sp||BGAL_ECOLI'))
</pre></font>



<p>
Sometimes it is desirable to iterate over the components
of a Seq-loc in a generic fashion.
For example, suppose that
some code expects to receive a Seq-loc (such as a
coding region) that consists of one or more intervals.
This Seq-loc might be a Seq-interval (if there is just one
interval), a Packed-seqint, or a mix.  If it is a mix,
it might contain all the intervals directly, but could instead
contain other mixes that contain intervals,
directly or indirectly, or contain Packed-seqint instances.
It would be inconvenient to have to write code
that deals explicitly with all of those possibilities.
The iterator class <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__loc__CI.html style=text-decoration:none>CSeq_loc_CI</a>
exists to allow generic iteration over the components
of a location so that this is not necessary.

<h3>Sequences, Sequence Sets, and Sequence Entries</h3>
A biological sequence is represented by a
<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Bioseq.html style=text-decoration:none>Bioseq</a>/<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCBioseq.html style=text-decoration:none>CBioseq</a>.
This contains the actual sequence instance (which
may be a reference to component sequences, or be empty)
and, optionally, some additional information: Seq-ids associated
with the sequence, annotations (including features),
and sequence descriptors.
A <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Bioseq-set.html style=text-decoration:none>Bioseq-set</a>/<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCBioseq__set.html style=text-decoration:none>CBioseq_set</a>
brings together a set of Bioseqs,
along with additional information such as annotations
and descriptors that apply to the sequences.
A <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-entry.html style=text-decoration:none>Seq-entry</a>/<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__entry.html style=text-decoration:none>CSeq_entry</a>
is a wrapper for a Bioseq or
a Bioseq-set.  The contents of these types and their
relationships to each other
are best understood from their ASN.1 specifications.

<p>
Bioseqs, etc., can be constructed by a program, but
are often read from files or over the network from
NCBI's databases.  A Seq-entry for the <em>E. coli</em>
beta-galactosidase protein can be read from an example
data file as follows:

<font color="brown"><pre>
bgal = ncbi.ReadAsnFile('data/bgal.prt')
bgal
<em>&lt;C ncbi::objects::CSeq_entry instance at _5042fe08_p_ncbi__objects__CSeq_entry&gt;</em>
bgal.GetSeq().IsNa()
<em>False</em>
bgal.GetSeq().IsAa()
<em>True</em>
</pre></font>



(<b>Note</b>: you will need to use a different path to the data directory
unless you are working in the directory that contains it.)


<p>
The Seq-entry associated
with an id can be loaded from the network by
several mechanisms, such as the ID1 client
(<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCID1Client.html style=text-decoration:none>CID1Client</a>):

<font color="brown"><pre>
cli = ncbi.CID1Client()
ch22 = cli.FetchEntry('NC_000022')
ch22
<em>&lt;C ncbi::objects::CSeq_entry instance at _880cb90a_p_ncbi__objects__CSeq_entry&gt;</em>
</pre></font>



However, for a number of reasons it will usually be
preferable not to do so directly but to use the Object Manager,
described next, instead.

<h3>Accessing Sequence and Feature Data with the Object Manager</h3>

Sequence-related biological data is contained within
Bioseqs and Bioseq-sets.  Yet dealing with these directly
is often not a convenient way of accessing the data of interest.
If you look at the human chromosome 22 entry fetched above
(<code>ch22</code>), you will see that it contains no
actual sequence data, just instructions on how to
construct the sequence from other sequences
(which, in this case, are themselves constructed sequences).
Even when a Bioseq contains raw sequence data, accessing
it directly can be a bit tricky.  The chromosome 22 entry
also lacks sequence features; the relevant features are
found on the sequences from which it is constructed.
To complicate matters, annotations pertinent to a
Bioseq may be attached to a Bioseq-set that contains it.
The <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?rid=toolkit.chapter.ch_objmgr">Object Manager</a>
exists to facilitate access to
data such as this that may come from a variety of sources,
and to hide details such as the method of database access
from the user.

<p>
Class <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCObjectManager.html style=text-decoration:none>CObjectManager</a>
is at the heart of a
versatile system for accessing data from various sources.
Class <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSimpleOM.html style=text-decoration:none>CSimpleOM</a>
provides a simplified interface that
knows how to load data from NCBI's public sequence database
(this includes, but is not limited to, the contents of the
Entrez nucleotide and protein databases).
This simplified interface will suffice
for many purposes, and is discussed here.

<h4>Retrieving Sequences as Strings</h4>
Class CSimpleOM provides a convenient (but not necessarily efficient)
means of retrieving sequence data as an IUPAC string
(the familiar alphabetic representation, including some ambiguity characters).
The sequence of pUC19, accession L09137, can be obtained as follows:

<font color="brown"><pre>
seq = ncbi.CSimpleOM.GetIupac('L09137')
</pre></font>


In this example the sequence id was passed as a string,
but it can also be given as a integer (representing a gi), a
CSeq_id, or a <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__id__Handle.html style=text-decoration:none>CSeq_id_Handle</a>
(an Object Manager type not discussed here).
Sequence data can also be obtained for a Seq-loc, for
example <code>mix_loc</code> from above:

<font color="brown"><pre>
seq2 = ncbi.CSimpleOM.GetIupac(mix_loc)
</pre></font>


The Object Manager takes care of
splicing together the sequences of the components of
the location and reverse-complementing one of them.

<h4>Sequence Vectors: <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeqVector.html style=text-decoration:none>CSeqVector</a></h4>
Calling the GetIupac method of CSimpleOM is fine for pUC19 with its measly 2.7kb
of sequence.  Doing the same for, e.g., a mammalian chromosome, with
on the order of 100Mb of sequence, will consume significant memory resources.
Furthermore, it causes the whole sequence to be retrieved,
which can be time-consuming.  This retrieval may be inevitable,
but some applications will use only a small fraction of the sequence.
The bits of interest could be retrieved using GetIupac calls
with CSeq_loc arguments, but a more string-like interface
can be convenient.

Objects of class <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeqVector.html style=text-decoration:none>CSeqVector</a>
provide access to
sequence data and can be indexed much like a
string or vector (but for read access only).
Suppose that we wanted to access some sequence from
human chromosome 22:

<font color="brown"><pre>
vec = ncbi.CSimpleOM.GetSeqVector('NC_000022.7')
vec.SetIupacCoding()
vec[20000000:20000050]
<em>'ATCCACTGAGTGTGCTGACCCCCACGCTTGTACCCACCTGCTAACACAGA'</em>
</pre></font>


The call to SetIupacCoding set the CSeqVector
to return IUPAC characters
(the default codings are useful for many purposes,
but not very human-readable).

(The Python interface includes an extension
to CSeqVector
to allow slicing operations such as <code>vec[20000000:20000050]</code>.
These behave like standard Python slicing operators: the "end"
position, 20000050 in this case, is not included in the range,
and negative indices can be used to refer to locations
relative to the end of the sequence.)
The requested subsequence
was automatically fetched
from the network for us and converted into IUPAC format.
Furthermore, the entire 50 megabase sequence was not necessarily
loaded into memory all at once or even fetched.

<p>
Like GetIupac, GetSeqVector can accept either a sequence
identifier in any of four forms (a string, an integer (gi),
a CSeq_id, or a CSeq_id_Handle) or a sequence location
(CSeq_loc).

<h4>Sequence Handles: <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCBioseq__Handle.html style=text-decoration:none>CBioseq_Handle</a></h4>

An instance of <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCBioseq__Handle.html style=text-decoration:none>CBioseq_Handle</a>
is a light-weight proxy for
a sequence that the Object Manager knows about.
It is the starting point for accessing the underlying data,
and is taken as a parameter by many functions that
perform analyses on sequences and related data.
A CBioseq_Handle for a sequence in NCBI's public database
can be created from a Seq-id that refers to it as follows:

<font color="brown"><pre>
hand = ncbi.CSimpleOM.GetBioseqHandle('NC_000022.7')
</pre></font>


The methods of CBioseq_Handle provide data access, e.g.,

<font color="brown"><pre>
hand.GetBioseqMolType() == ncbi.CSeq_inst.eMol_aa
<em>False</em>
hand.GetBioseqMolType() == ncbi.CSeq_inst.eMol_dna
<em>True</em>
hand.GetBioseqLength()
<em>49396972</em>
</pre></font>


Some things that can be done with a sequence handle
are obtaining a sequence vector
(using method GetSeqVector), obtaining the whole Bioseq
or a skeletal version of it (using GetCompleteBioseq or
GetBioseqCore), and accessing annotated sequence features
(described below).

<h4>Object Manager Scopes: <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCScope.html style=text-decoration:none>CScope</a></h4>

Central to the Object Manager is the notion of a scope,
represented by class <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCScope.html style=text-decoration:none>CScope</a>.
A scope specifies a universe from which sequence
entries and related data can be loaded.
This universe is defined by the data loaders that
have been added to the scope and/or
sequence entries and annotations that have been attached to it directly.

<p>
A common requirement is for a scope that knows
how to retrieve data from NCBI's public sequence databases
over the network 
(via data loader <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCGBDataLoader.html style=text-decoration:none>CGBDataLoader</a>).
A scope like this is created by CSimpleOM every
time GetBioseqHandle, GetSeqVector, or GetIupac is called.
Such a scope may be obtained directly as follows:

<font color="brown"><pre>
scope = ncbi.CSimpleOM.NewScope()
</pre></font>


It may be necessary to create such a scope explicitly
because many functions require a CScope as a parameter:

<font color="brown"><pre>
ncbi.GetGiForAccession('NC_000022.7', scope)
<em>42406309</em>
</pre></font>


Furthermore, sequence entries that have been constructed
by a program or read from a file can be attached to a
scope.  This can be useful because it allows use of
the Object Manager's facilities for accessing the data,
and it is necessary for use of some functions that take a
scope as a parameter.  Suppose, for example, that you have
read sequences from a FASTA file, using <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCFastaReader.html style=text-decoration:none>CFastaReader</a>,
to obtain a sequence entry
<code><font color="brown">ent</font></code>.
You can add this to a scope with

<font color="brown"><pre>
scope.AddTopLevelSeqEntry(ent)
</pre></font>


Now the scope can resolve references to the sequences from
the FASTA file, so you can do things like

<font color="brown"><pre>
hand = scope.GetBioseqHandle('lcl|my_id42')
hand.GetBioseqLength()
</pre></font>


Furthermore, you can now use the scope with other data objects that
refer to these sequences.  If, for example, you have a sequence
that is constructed from these sequences, perhaps loaded from an
AGP file, you can add that to the scope too and the Object Manger
can transparently stitch together the sequence for you.  If you have an
alignment (<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__align.html style=text-decoration:none>CSeq_align</a> object)
that involves these sequences,
you can use this scope with it for analysis and display.
<p>
Both CBioseq_Handle and CSeqVector have a GetScope method
that returns the associated scope.

<h4>Accessing Sequence Features</h4>

A wealth of information about sequences is stored in annotated
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SDKDOCS/SEQFEAT.HTML">
sequence features</a>.  The features associated with a sequence,
or some specified subset of them, can be accessed using
a feature iterator (class <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCFeat__CI.html style=text-decoration:none>CFeat_CI</a>).
There are many ways to construct a feature iterator.
In some of these an <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/structSAnnotSelector.html style=text-decoration:none>SAnnotSelector</a>
is used to specify how the search for features should proceed
(<a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?rid=toolkit.section.ch_objmgr.object_manager4#ch_objmgr.om_attrib.html_SAnnot_selector">see details</a>).
Often this specification includes restricting attention to features
of a certain
type (<a href="http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeqFeatData__Base.html#5487d8c754b2f18436ef729d481fc87b">list of possibilities</a>)
or subtype
(<a href="http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeqFeatData.html#ce616425690d509dd987df0e52d19141">list of possibilities</a>).
Suppose that we wanted to look at all of the annotated repeat regions
in a certain region of human chromosome 22.  We might do the following:

<font color="brown"><pre>
sel = ncbi.SAnnotSelector()
sel.SetResolveAll()
<em>&lt;C ncbi::objects::SAnnotSelector instance at _c81a0c0a_p_ncbi__objects__SAnnotSelector&gt;</em>
sel.SetFeatSubtype(ncbi.CSeqFeatData.eSubtype_repeat_region)
<em>&lt;C ncbi::objects::SAnnotSelector instance at _c81a0c0a_p_ncbi__objects__SAnnotSelector&gt;</em>
region = ncbi.CSeq_loc()
region.SetInt().SetId(ncbi.CSeq_id('NC_000022.7'))
region.SetInt().SetFrom(20000000)
region.SetInt().SetTo(21000000)
scope = ncbi.CSimpleOM.NewScope()
it = ncbi.CFeat_CI(scope, region, sel)
it.GetSize()
<em>1445</em>
</pre></font>




The call to SetResolveAll() is crucial here; it says to include
the component sequences out of which our sequence is construced in the
search for features (recall that the "NC" record itself contains
no features).  The call to the GetSize() method
of our iterator shows that 1445 features were found that
match our criteria.  <code>it</code> points at the first
of these:


<font color="brown"><pre>
print it.GetMappedFeature().Asn()
<em>Seq-feat ::= {
  data imp {
    key "repeat_region"
  },
  location int {
    from 20002204,
    to 20002327,
    id other {
      accession "NC_000022",
      version 7
    }
  },
  qual {
    {
      qual "rpt_family",
      val "AluSq/x"
    }
  },
  exp-ev not-experimental
}</em>
</pre></font>




It can be incremented, using Incr(), to point at the next one:

<font color="brown"><pre>
it.Incr()
<em>&lt;C ncbi::objects::CFeat_CI instance at _98c6900b_p_ncbi__objects__CFeat_CI&gt;</em>
print it.GetMappedFeature().Asn()
<em>Seq-feat ::= {
  data imp {
    key "repeat_region"
  },
  location int {
    from 20003241,
    to 20003264,
    id other {
      accession "NC_000022",
      version 7
    }
  },
  qual {
    {
      qual "rpt_family",
      val "AT_rich"
    }
  },
  exp-ev not-experimental
}</em>
</pre></font>


The iterator can also be decremented using Decr() or
"rewound" to the beginning using Rewind().
It can be tested for validity in a conditional
(for example, in the while() in the example below)
or explicitly using <code>bool(it)</code>.

This test will return false if the iterator
has been incremented past the last feature.

<h4>A Complete Example</h4>

The following example, inspired by a real-world need,
illustrates the use of
several aspects of the Object Manager
and actually does something useful.
This code tallies the start and stop codons used by
annotated coding regions, and keeps track of
those with unusual starts or stops.
It iterates over all annotated coding regions
on a version of human chromosome 14 (accession NC_000014.7).
It screens each for flags indicating
that something is unusual about this coding region: the
"pseudo" flag, the "partial" flag, and the "except" flag.
If none of these are set to true, it retrieves the sequence of the
coding region.  It examines the first three and
last three nucleotides (presumptive start and stop codons).
It adds these to tallies of start and stop codon utilization.
Additionally, if the start or stop is unusual, a copy of the
iterator is made and added to a list for later inspection.

In my experience this takes about a minute to run.


<font color="brown"><pre>
start_counts = {}
stop_counts = {}
partial_count = 0
pseudo_count = 0
except_count = 0
non_aug_start = []
non_standard_stop = []

sel = ncbi.SAnnotSelector(ncbi.CSeqFeatData.e_Cdregion)
sel.SetResolveAll()
sel.SetAdaptiveDepth(True)
hand = ncbi.CSimpleOM.GetBioseqHandle('NC_000014.7')
it = ncbi.CFeat_CI(hand, sel)

while(it):
    if it.IsSetPseudo() and it.GetPseudo():
        pseudo_count += 1
    elif it.IsSetExcept() and it.GetExcept():
        except_count += 1
    elif it.GetPartial():
        partial_count += 1
    else:
        seq = ncbi.CSimpleOM.GetSeqVector(it.GetLocation())
        seq.SetIupacCoding()
        start = seq[0:3]
        if not start in start_counts:
            start_counts[start] = 0
        start_counts[start] += 1
        if not start == 'ATG':
            non_aug_start.append(ncbi.CFeat_CI(it))
        stop = seq[-3:]
        if not stop in stop_counts:
            stop_counts[stop] = 0
        stop_counts[stop] += 1
        if not stop in ['TAA', 'TAG', 'TGA']:
            non_standard_stop.append(ncbi.CFeat_CI(it))
    it.Incr()
</pre></font>





Now we can explore the results, e.g.,

<font color="brown"><pre>
print stop_counts
<em>{'AAA': 1, 'TAG': 135, 'TGA': 321, 'TAA': 220}</em>
</pre></font>




This indicates a greater than two-fold excess of
UGA over UAG, despite their identical base compositions.
It also shows that a codon that is not a cannonical stop, AAA,
occurs at the end of one coding region.  Using the 
saved list of such features, e.g.,


<font color="brown"><pre>
print non_standard_stop[0].GetOriginalFeature().Asn()
<em>(output omitted)</em>
</pre></font>




we can track this down to
<a href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=gene&cmd=Retrieve&dopt=Graphics&list_uids=3505">
this pseudogene</a>.  This coding region
should probably be flagged as "pseudo".

<p>
A similar look at the start codons shows that with the exception
of the pseudogene that slipped through, all begin with AUG.
This can be contrasted with the situation in many prokaryotes;
running the above with the accession of the
<em>E. coli</em> chromosome, 'NC_000913.2', substituted
for 'NC_000014.7' shows that
alternative starts, mostly GUG, are used in more than 15% of
the annotated coding regions of that genome.

<h3>Performing Entrez Queries</h3>

Many of NCBI's databases, such as
the nucleotide, protein, and PubMed databases, can
be queried using
<a href="http://www.ncbi.nlm.nih.gov/entrez/query/static/help/helpdoc.html">Entrez</a>.
In the C++ Toolkit, Entrez queries
are performed using instances of the class
<a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCEntrez2Client.html style=text-decoration:none>CEntrez2Client</a>.
This class has many methods for performing different types
of queries.  A simple query with a
<a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?rid=helpentrez.section.EntrezHelp.Boolean_Operators">
boolean expression</a> can
be accomplished with the Query method:

<font color="brown"><pre>
e2c = ncbi.CEntrez2Client()
result = ncbi.vector_int()
e2c.Query('Homo sapiens[ORGN] AND phosphatase', 'nucleotide', result)
len(result)
<em>132939</em>
result[0]
<em>38014109</em>
</pre></font>


(Note: because the Entrez databases are constantly changing,
your results will differ from those shown here.)
The variable <code>result</code> is a vector of gi's of matching entries.
These can be used as identifiers for retrieving sequences, accessing
features, etc.:

<font color="brown"><pre>
hand0 = ncbi.CSimpleOM.GetBioseqHandle(result[0])
hand0.GetBioseqLength()
<em>1994</em>
print hand0.GetDescr().Asn()
<em>(lengthy output omitted)</em>
</pre></font>


Entrez neigbors can be obtained using the GetNeighbors
method.  For example, the ids of the PubMed neighbors of the first
match above can be obtained as follows:

<font color="brown"><pre>
pubmed_neighbors = ncbi.vector_int()
e2c.GetNeighbors(result[0], 'nucleotide', 'pubmed', pubmed_neighbors)
len(pubmed_neighbors)
<em>1</em>
pubmed_neighbors[0]
<em>12477932</em>
</pre></font>


If desired, the actual Medline entries can be retrieved using
class <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCMLAClient.html style=text-decoration:none>CMLAClient</a>
(e.g., using method AskGetmle).

<p>
Voluminous information about the Entrez server may be obtained
with the AskGet_info method:

<font color="brown"><pre>
info = e2c.AskGet_info()
</pre></font>


Examination of the (lengthy) ASN.1 dump of <code>info</code>
(e.g., using 
<code><font color="brown">info.TextView()</font></code>)
will reveal
the names of all of the available databases, the searcheable fields for each,
the types of links available, etc.

<h3>Reading and Writing Various File Formats</h3>

The C++ Toolkit provides facilities for reading and writing
various file formats.  ASN.1, XML, and JSON representations have
already been discussed.  The Toolkit also reads and writes
several other file formats, many of them widely used.  The Toolkit
functionality generally produces NCBI data model objects upon reading
and accepts data model objects for writing.  It may therefore be of use
to you even if you have other ways of parsing and writing these formats
in Python.
Below is an incomplete list of formats that can be read and/or written,
along with the classes or functions that provide the capabilities.

<p>
Reading and writing is generally done to or from a
C++ stream.  The standard stream library is present in the
wrappers.  Note that stream classes are referred to in the
Toolkit by aliases.  For example, CNcbiIstream is, for our purposes,
an alias for istream, and CNcbiOstream is an alias for ostream.

<p>
To read from or write to a file, one typically creates an instance
of ifstream or ofstream, which are subclasses of istream and ostream:


<font color="brown"><pre>
istr = ncbi.ifstream('some_input_file')
ostr = ncbi.ofstream('some_output_file')  # N.B.: overwrites file if it exists
</pre></font>



Some other possibilities for istream and ostream are
classes istringstream and ostringstream, which let you read from or
write to strings in memory, and objects cin, cout, and cerr, which represent
standard input, standard output, and standard error.

<p>

<table>
<tr><th>Format</th><th>Reading</th><th>Writing</th></tr>
<tr><td>FASTA format sequences</td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCFastaReader.html style=text-decoration:none>CFastaReader</a></td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCFastaOstream.html style=text-decoration:none>CFastaOstream</a></td></tr>
<tr><td><a href="http://www/projects/genome/guide/Assembly/AGP_Specification.html">AGP</a></td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/agp__read_8hpp.html style=text-decoration:none>AgpRead</a></td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/include_2objtools_2writers_2agp__write_8hpp.html style=text-decoration:none>AgpWrite</a></td></tr>
<tr><td>BLAST database</td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeqDB.html style=text-decoration:none>CSeqDB</a><!-- , classes declared <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/blastdb__dataextract_8hpp.html style=text-decoration:none>here</a> --></td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCWriteDB.html style=text-decoration:none>CWriteDB</a></td></tr>
<tr><td>GFF/GTF</td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCGFFReader.html style=text-decoration:none>CGFFReader</a></td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCFlatFileGenerator.html style=text-decoration:none>CFlatFileGenerator</a></td></tr>
<tr><td>GenBank, EMBL, GBSeqXML, etc.</td><td></td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCFlatFileGenerator.html style=text-decoration:none>CFlatFileGenerator</a></td></tr>
<tr><td>CLUSTAL alignment, etc.</td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCAlnReader.html style=text-decoration:none>CAlnReader</a></td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCAlnVecPrinter.html style=text-decoration:none>CAlnVecPrinter</a></td></tr>
<tr><td><a href="http://evolution.genetics.washington.edu/phylip/newicktree.html">Newick</a> (phylogenetic trees)</td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/phy__node_8hpp.html#f5b4242d59c1ed952814b9242e360816 style=text-decoration:none>ReadNewickTree</td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/phy__node_8hpp.html#0dd990a81796f7f3d72e45b21ca0d993 style=text-decoration:none>operator&lt&lt for TPhyTreeNode</a></td></tr>
<tr><td>glimmer3 output</td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCGlimmerReader.html style=text-decoration:none>CGlimmerReader</a></td><td></td></tr>
<tr><td>repeatmasker output</td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCRmReader.html style=text-decoration:none>CRmReader</a></td><td></td></tr>
<tr><td>Phrap/ACE assembly</td><td><a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/phrap_8hpp.html style=text-decoration:none>ReadPhrap</a></td><td></td></tr>

<tr><td></td><td></td><td></td></tr>
</table>

<p>
<!-- Begin footer content -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT>
<a NAME="copyright"></a>
<address>
<a href="mailto:jcherry@ncbi.nlm.nih.gov">Josh Cherry</a>&nbsp;</address>
</td>

<td>


</tr>
</table>

</body>

</html>
