<html>
<head>
</head>

<body>

<h2>Dealing with Pointers and References to Built-in Types in
Python</h2>

Python
lacks the native ability to manipulate C/C++ pointers and references.
Occasionally it is necessary to work with pointers or references
to built-in C++ types.  Such situations are rare because the Toolkit
maily uses a <code>std::vector</code>, <code>std::string</code>,
or other class where a C
program might have used a C array.  Nonetheless, methods of
dealing with these situations are needed when they do occur.
These are described here.
<p>
It is recommended that new users read just the summary portion
of each section below and turn to the details only when faced
with the situation described.  Users should also be aware
of the
<a href="add_ons_python.html#reinterpret_cast">reinterpret_cast</a>
function, which can be useful for dealing with pointers to built-in types.

<h3>Passing Non-const Reference or Single-element Pointer Parameters</h3>

<h4>Summary</h4>
Some functions take a non-const reference or
pointer argument so they can return a single value through the argument.
In these cases it is necessary to pass a representation of a valid
pointer as the argument.  One approach is to create and pass an instance
of a special class provided for this purpose: int_p for int,
long_long_p for long long, etc.  The value of the underlying
int, etc., can be obtained with the <code>value()</code> method of the
class and set with the <code>assign()</code> method.
<h4>Details</h4>
A function may take a non-const reference or pointer argument,
where the pointer points to a single element (as opposed to an array),
so that it can in effect return a value through the argument.
A reference almost always refers to a single element, whereas
a pointer might refer to an array instead; the user will have
to determine the intent from the context and the function documentation,
just as a C++ programmer would.  In some cases the initial value
of the element might matter too (the argument may serve as both
input and output); again, the programmer will, one hopes,
be able to determine the semantics of any particular function.
Non-const references and pointers will be handled in the same
way (references are, in a sense, pointers in disguise).
<p>
Suppose that a C++ function takes an <code>int</code> reference
(<code>int&</code>) as an argument.
One might guess that setting a
Python variable
to an integer and passing that would work.  In reality it will fail,
with an error about the parameter type.
In fact it would violate the immutability of Python integers
if they could be modified in this way.  Instead, one must pass
a pointer to a C++ <code>int</code>
(a Python wrapper
representation of a pointer, that is).
In some cases it will make sense to pass
a pointer returned by another function.  In most cases, however,
users will have no such pointer and will need to obtain one
that points at an <code>int</code> that has been allocated
for this purpose.
For these cases the wrapper provides special classes
for <code>int</code> and other built-in types.
These classes allocate an instance of the relevant type
dynamically and provide
access to the instance and its address.  The classes are named
<code>int_p</code> for <code>int</code> pointer,
<code>unsigned_long_p</code> for <code>unsigned long</code> pointer,
and so on.
<p>
For example, class <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCTaxon1.html style=text-decoration:none>CTaxon1</a>,
which retrieves taxonomic information from a server at NCBI,
has the following method:
<pre>
CConstRef&lt;COrg_ref&gt; GetOrgRef(int tax_id, bool &is_species, bool &is_uncultured, string &blast_name);
</pre>
In addtion to returning an <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Org-ref.html style=text-decoration:none>Org-ref</a>, it
returns information through three arguments passed by reference,
two of which are booleans and one a <code>std::string</code>.
The string is handled
like any other class: create an instance and pass it.  For the
<code>bool</code> arguments we can use one of the special classes discussed
above, namely <code>bool_p</code>.
The following code retrieves information for tax_id 9606,
the ID for <i>Homo sapiens</i>:


<font color="brown"><pre>
is_species = ncbi.bool_p()
is_uncultured = ncbi.bool_p()
blast_name = ncbi.string()

cl = ncbi.CTaxon1() 
cl.Init()
org_ref = cl.GetOrgRef(9606, is_species, is_uncultured, blast_name)

print is_species.value()
<em>True</em>
print is_uncultured.value()
<em>False</em>
print blast_name
<em>primates</em>
</pre></font>



We see that 9606 is indeed the taxonomic ID of a species
(as opposed to, say, a phylum or a subspecies).  Furthermore,
we see that although some individuals may lack culture, our
species as a whole is not uncultured in the sense in which
some microorganisms are.


<h3>Arrays as Arguments</h3>

<h4>Summary</h4>
When a C array of a built-in type T is needed
as a function argument, construct a <code>vector&lt;T&gt;</code>
(named <code>vector_T</code>
in Python)
and call its <code>data()</code> method to obtain a pointer.  So as not
to invalidate the pointer prematurely, be sure that the vector
continues to exist for as long as necessary, and that its size
is not increased.
<h4>Details</h4>
Some funtions require a pointer argument that
refers to an array of sufficient size.  The recommended
general solution, when such a pointer is not already available,
is to construct a vector of the appropriate type and size
and call its <code>data()</code> method to get a pointer.
The <code>data()</code>
method does not exist in C++ but is added to the
Python
wrapper.  It returns the address of the first element
of the vector's internal array (in C++ one could
simply take the address of that element, <code>&vec[0]</code>).
It is legal to read from and write to the resulting
array, within the limits, of course, of the size of the
vector.
<p>
Note that appending to the vector or otherwise
increasing its size may cause it to reallocate its internal
array, which would invalidate a pointer previously obtained
from data().  Thus, no such operations may be performed
during any time when the pointer must remain valid
(e.g., between function calls that use the same pointer
as an argument, or during the lifetime of an object
that copies the pointer and relies on its validity).
Also, the vector must continue to exist for the pointer
to remain valid; if it is deleted explicitly or because
it goes out of scope, it will delete its internal array.
<p>
Pointers to <code>char</code> (<code>char *</code>) are treated
a bit differently by SWIG and hence by the wrapper: it is always
possible to pass a Python
string for a <code>char *</code> argument.  However, if the
function makes changes to its <code>char *</code> argument,
these will not be reflected in the
Python string.
Thus, although passing a
Python string
is acceptable and convenient for functions that only read
their argument, for those that write it a pointer argument
will be needed (unless the result string is of no importance).
Using a <code>vector</code> as described above, specifically
a <code>vector&lt;char&gt;</code>, is one approach.
Note that it is inadvisable to use a <code>std::string</code>
for this purpose; the <code>data()</code> and <code>c_str()</code>
methods of <code>std::string</code> yield const pointers in C++,
so their return values should not be used in this way.
<p>
A pointer of any type may be passed for a <code>void *</code> argument.
The choice of type to use depends on what data will go
there and how it should be interpreted.  Often a <code>void *</code>
is used for byte data, so some sort of character type
is appropriate.  By choosing among <code>char</code>,
<code>signed char</code>,
and <code>unsigned char</code> vectors you can control whether
bytes are interpreted as characters (single-character
strings in Python),
signed integers ranging from -128 to 127, or unsigned integers
ranging from 0 to 255.
<p>
The code below illustrates the use of the internal array
of a <code>vector</code> as described here.  The Toolkit
contains the following low-level function, which retrieves
the name of the computer on which it is being run:
<pre>
int SOCK_gethostname(char* name, size_t namelen);
</pre>
(Normally one would not call this function directly;
use <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSocketAPI.html style=text-decoration:none>CSocketAPI</a>::gethostname,
which returns a <code>std::string</code>, instead.)
In addition to a <code>char *</code> for writing, it
takes the length of the <code>char</code> array so that it can
write a truncated string if necessary.  The function can
be called from Python
as follows:

<font color="brown"><pre>
name = ncbi.vector_char(100)
ncbi.SOCK_gethostname(name.data(), name.size())
</pre></font>




Now the result can be accessed through the vector:

<font color="brown"><pre>
print name[0]
print name[1]
</pre></font>


(This will show the first two characters of the hostname.)
It may be convenient to construct a string at this point:

<font color="brown"><pre>
s = ncbi.string(name.data())
print s
</pre></font>


(This will show the entire hostname.)
In this case the <code>char</code> array was known to be null-terminated;
had it not been, its length would need to be known and passed to
the <code>string</code> constructor
(<code>ncbi.string(name.data(), length)</code>)
.



<h3>Pointers and References as Return Values</h3>

<h4>Summary</h4>
Some functions return a pointer to a built-in type.
Others return a non-const reference, yielding the same result in
Python.
The wrappers contain functions and classes that
allow access to the pointed-at data, whether it is a single
element or an array.  Function
<code>deref()</code> can be used to get the value of the
single element pointed at or of any element of an array.
Assignment is provided by <code>deref_assign()</code>
in the single-element case and 
<code>array_assign()</code> in the array case.  Function
<code>Array()</code> constructs an object of an array class that
provides convenient read and write access.

<h4>Details</h4>

Some functions return a const or non-const reference
or pointer to a built-in type.
If a function returns a const reference, the result in
Python is
the same as in the case of return by value, e.g.,
a Python integer or long
 in the case of
an integral C++ type (e.g., <code>const int&amp;</code>).
If a non-const reference
or any pointer is returned, however, the result in
Python
is a representation of a pointer.  This representation
is fairly opaque--by itself, it cannot reveal the value
of what it points at--but it can be passed to functions
in the wrapper that expect a pointer.  Functions and classes
are provided that allow determining and altering the value(s)
of the data to which the pointer refers.
<p>
The meaning and intended use of the pointer should
be determined from the context and function documentation.
A reference almost certainly refers to a single element,
but a pointer might refer to a single element or to an array.
A pointer might be null, represented by
<code>None</code> in Python;

whether a null pointer can be returned, and what this means, depends
on the function (there is no such thing as a null reference).
It may be intended that the caller receiving the
pointer make changes to the underlying data.
Indeed this is likely an intended option when an non-const
pointer or reference is returned, and is the main reason
for returning a small type, such as an int,
by reference rather than by value.  It is most certainly
not the intent when a const pointer is returned, but
unfortunately SWIG and hence the wrapper does not
enforce the read-only constraint.
<p>
The wrapper provides two methods of read/write access
to pointed-at data.  The first consists of functions
for reading and writing that take a pointer as an
argument.  The second is class-based and provides array-like
access using an object constructed from the pointer.
<p>
Function <code>deref()</code> provides read access to data referefenced
by a pointer, and functions <code>deref_assign()</code> and 
<code>array_assign()</code> provide write access.
<code>deref(ptr)</code>
,
where
<code>ptr</code>
 is
a pointer to a built-in type, returns the value that
it points at (<code>*ptr</code> in C++).
<code>deref(ptr, i)</code>,

where
<code>i</code>
 is an integer,
returns the value indexed by <code>i</code> (<code>ptr[i]</code>).  
<code>deref_assign(ptr, val)
</code>
sets the element pointed at by
<code>ptr</code>
to
<code>val</code>
(equivalent to <code>*ptr = val</code>).
<code>
array_assign(ptr, i, val)

</code>
sets the element indexed by 
<code>i</code>
to
<code>val</code>
(equivalent to <code>ptr[i] = val</code>).
<p>
An array-like object can be constructed from a pointer
by calling function <code>Array()</code>.  This returns an array
of the appropriate type (Array_int, Array_long_long, etc.).
<code>
Array(ptr)

</code>
produces an array object with no size set; it will allow you to
use any non-negative index, which can lead to trouble if you
exceed the bounds of the "real" array.
<code>
Array(ptr, size)

</code>
sets the size.  The resulting array will raise an exception
if an index exceeds the array bounds.  Also, if the size
is set then negative indices can be used to refer to
positions relative to the end of the array, with -1 referring
to the last element (it is not possible to access true
negative indices of the pointer with an array object; use
the functions described above instead).  If the size of the
array is unknown when <code>Array()</code> is called but is known later,
it can be set with the array's <code>set_size()</code> method.
Array elements are accessed for reading and writing using 
square brackets (<code>[]</code>) in the familiar way
.
The <code>ptr()</code> method returns the underlying pointer.
<p>
An example of return by pointer is provided by class CRegexp.
Its <code>GetMatch()</code> method returns an
<code>int</code> pointer (<code>int *</code>)
corresponding to an array of length two that gives
the location of a regular expression match or submatch.
A pointer to such an array can be obtained from a simple
search like this:


<font color="brown"><pre>
regexp = ncbi.CRegexp('foo')
regexp.GetMatch('abc foo xyz')
<em>'foo'</em>
ptr = regexp.GetResults(0)
print ptr
<em><Swig Object at _d0971308_p_int></em>
</pre></font>



We can access the values in this array using deref():


<font color="brown"><pre>
ncbi.deref(ptr)     # The int that ptr points at, *ptr
<em>4</em>
ncbi.deref(ptr, 0)  # Equivalently, element 0, ptr[0]
<em>4</em>
ncbi.deref(ptr, 1)  # The next element, ptr[1]
<em>7</em>
</pre></font>



We can also use <code>Array()</code> to create an object that allows
array-like access:


<font color="brown"><pre>
ar = ncbi.Array(ptr, 2)
ar[0]
<em>4</em>
ar[1]
<em>7</em>
ar[-1]  # -1 means the last element
<em>7</em>
ar[2]   # Oops, out of range
<em>Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "deref.py", line 187, in __getitem__
    def __getitem__(*args): return _deref.Array_int___getitem__(*args)
IndexError: index out of range<em>
</pre></font>















<font color="brown"><pre>

</pre></font>






<p>
<!-- Begin footer content -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT>
<a NAME="copyright"></a>
<address>
<a href="mailto:jcherry@ncbi.nlm.nih.gov">Josh Cherry</a>&nbsp;</address>
</td>

<td>


</tr>
</table>

</body>

</html>
