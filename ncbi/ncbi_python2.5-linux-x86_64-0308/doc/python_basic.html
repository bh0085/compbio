<h2>Using the Python Interface to the NCBI C++ Toolkit</h2>

<h3>Configuring and Running Python</h3>

Depending on where the NCBI Python module has been installed,
you may need to set or adjust your PYTHONPATH environment
variable.  If it has been installed in a standard place,
or you are running in the directory where the module is
located, you shouldn't need to do anything.

<p>
You can just type <code>python</code> at your
unix prompt to enter an interactive session.
You can of course also run Python scripts stored in files
using the usual unix mechanisms, or execute a file
from the interactive Python prompt using <code>execfile()</code>.

<p>
The Python shell for unix, if built appropriately,
makes use of GNU Readline.  This means that you can edit
command lines with familiar keystrokes, and scroll through
your command history using the up- and down-arrows, much as
in bash and tcsh.  It is also possible to set up command completion
(also similar to what is available in bash and tcsh).  I highly
recommend this--it is one of those things that I can't imagine
living without now that I'm used to it.  This can be set up
using a Python initialization file as described in the
<a href="http://docs.python.org/lib/module-rlcompleter.html">
rlcompleter documentation</a>.
Such a file is usually put in the user's home directory
and named .pythonrc.  This is just a convention though, and you
must explicitly tell Python to execute this file at startup
by setting the environment variable PYTHONSTARTUP to the file's path.
Note that this file is executed automatically only for interactive
sessions, not when scripts are run.

<p>
Some Python tutorials can be found
<a href="http://www.python.org/doc/">here</a>.
If you're new to Python, perhaps the most important thing
to note is that indentation is significant in Python:
it's how statements are grouped, as they would be grouped with
braces in C/C++ or Perl.  Thus
<font color="brown"><pre>
if 0:
    print "foo"
    print "bar"
</pre></font>
and
<font color="brown"><pre>
if 0:
    print "foo"
print "bar"
</pre></font>
are different: the first prints nothing, while the second prints "bar".

<h3>The Python NCBI Module</h3>

<h4>Basic Usage</h4>

The Toolkit interface can be loaded into Python with
an <code>import ncbi</code> command.  All of its classes,
functions, etc. are then available in a namespace called
<code>ncbi</code>, i.e., as <code>ncbi.something</code>
(it is possible to import everything into the global namespace,
but I won't do that here; for one thing, it makes it clear
what's an NCBI interface as opposed to part of standard Python).
For example, the Toolkit defines a function called
CurrentTime() that returns the current time and date as an object,
so we could do something like this:
<font color="brown"><pre>
>>> import ncbi
>>> t = ncbi.CurrentTime()
>>> t
&lt;C ncbi::CTime instance at _10b47009_p_ncbi__CTime>
</pre></font>

<p>
As indicated when <code>t</code> was typed alone, the
variable <code>t</code> represents an object of
type <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCTime.html style=text-decoration:none>CTime</a>.
We can call methods of this object
using a "." syntax.  CTime defines a public method
called AsString():
<font color="brown"><pre>
>>> t.AsString()
'05/14/2007 11:25:42'
</pre></font>

<h4>Help and Documentation</h4>
One way to find out what methods are available
is to go to the C++ documentation manually,
but there are some more convenient ways:
<ul>
<li> If you've configured readline completion as described above,
you can type "<code>t.</code>" and hit tab twice to see a list of
completions.  This will include not only methods but also things
like enumeration values (e.g., <code>eTuesday</code>). Completion
can save you typing even when you know what you want: if you
type "<code>t.As</code>" and hit tab once, it will be expanded
to <code>t.AsString </code>.  Even if you haven't configured
readline completion, you can type <code>dir(t)</code> to see
a list of members.
<li> The Toolkit interface provides documentation that is accessible
through the Python help system.  Typing <code>help(ncbi.CTime)</code>
will show you the help for class CTime.  This help is in many ways
useful, but in some ways confusing (e.g., enumerations show up as
integers, pointer/reference/value distinctions are elided,
class-scope typedefs are referred to without any indication of
what they are).  Note that C++ constructors show up as
Python <code>__init__</code> methods.  <code>help</code>
can also be called on a function or method, e.g.
<code>help(t.AsString)</code>, <code>help(ncbi.CTime.AsString)</code>,
<code>help(ncbi.CurrentTime)</code>.
<li> C++ Toolkit documentation produced using Doxygen is available
through the web.  The Python interface provides convenient acces to
this with the <code>Doxy()</code> function and method.  Typing
<code>t.Doxy()</code> should bring up the web page for CTime in
a web browser (Note: This may fail on unix if your web browser is
not already running; many versions of Netscape and Mozilla do
not properly exit with nonzero status when a "remote" command fails).
The <code>Doxy</code> method can also be called on a class, and
the stand-alone <code>Doxy</code> function can be called
with a string as well as an object or a class.  Thus
<code>t.Doxy()</code>, <code>ncbi.CTime.Doxy()</code>,
and <code>ncbi.Doxy('CTime')</code> all accomplish the
same thing.
</ul>

<h4>Serial (ASN.1) Objects</h4>

Central to much of what NCBI does are "serial data types".
These are (usually) defined by an
<a href="http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/">
ASN.1 specification</a>,
and objects of these types can be written in and read
from ASN.1 text and binary formats and XML, and
written in (but not read from) JSON.
In the C++ Toolkit these are represented by classes
that derive from a class called <code>CSerialObject</code>
and that have names similar to the ASN.1 type.
For example, the <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Seq-loc.html style=text-decoration:none>Seq-loc</a> ASN.1 type is
represented by the class <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCSeq__loc.html style=text-decoration:none>CSeq_loc</a>.
In addition to the functionality provided by the Toolkit, the scripting
interfaces provide some add-ons to simplify serialization and
deserialization.

<p>
Let's create a <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml/classCDate.html style=text-decoration:none>CDate</a>
object, which represents an ASN.1 <a href=http://www.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/asn_spec/Date.html style=text-decoration:none>Date</a>,
initializing it with the CTime object <code>t</code> created above:
<font color="brown"><pre>
>>> d = ncbi.CDate(t)
>>> d
&lt;C ncbi::objects::CDate instance at _281ca709_p_ncbi__objects__CDate>
</pre></font>

We can get an ASN.1 text representation of <code>d</code> using
its <code>Asn()</code> add-on method:
<font color="brown"><pre>
>>> print d.Asn()
Date ::= std {
  year 2007,
  month 5,
  day 14,
  hour 11,
  minute 25,
  second 42
}
</pre></font>
The analogous methods AsnBin(), Xml(), and Json() yield ASN.1 binary,
XML, and JSON representations.  The methods FromAsn(), FromAsnBin(),
and FromXml() convert from the corresponding formats, taking
strings as input:
<font color="brown"><pre>
>>> id = ncbi.CSeq_id()
>>> s = '''
Seq-id ::= genbank {
  accession "L09137"
}
'''
>>> id.FromAsn(s)
>>> id.AsFastaString()
'gb|L09137|'
</pre></font>
(tripled quotes are used for multi-line strings in Python).
The FromAsnFile(), FromAsnBinFile(), and FromXmlFile()
methods take a file name and read the object from the file:
<font color="brown"><pre>
ch22 = ncbi.CSeq_entry()
ch22.FromAsnBinFile('/netopt/ncbi_tools/c++-wrappers/data/chromosome22.val')
</pre></font>
These methods can also take an input stream.  This allows reading
of more than one object from a file by repeated calling of the method
with the same input stream argument.
<p>
The Python interface provides convenient one-line
file-reading through three ReadXXXFile functions.  For example
<font color="brown"><pre>
bgal = ncbi.ReadAsnFile('data/bgal.prt')
</pre></font>
loads a Seq-entry from a text ASN.1 file.
(<b>Note</b>: you will need to use a different path to the data directory
unless you are working in the directory that contains it.)
Because it was text ASN.1,
the ASN.1 type could be determined from the file.  The same
would be true for XML using ReadXmlFile().  For binary ASN.1,
however, the type of the object must be specified:
<font color="brown"><pre>
ch22 = ncbi.ReadAsnBinFile('data/chromosome22.val', 'Seq-entry')
</pre></font>
(<b>Note</b>: again, you may need a different path to the data directory.)
The type can optionally be specified for the other serial formats.

<p>
Methods Serialize(), Deserialize(), and DeserializeFile(),
and function ReadSerialFile(), can be used to read and write
all three serial formats.  They take the format as a parameter,
and are useful for writing generic code.

<p>
All serial objects have an add-on method called <code>Spec()</code>
that attempts to retrieve the ASN.1 specification for the object
and print it to the screen:
<font color="brown"><pre>
>>> d.Spec()
Date ::= CHOICE {
    str VisibleString ,        -- for those unparsed dates
    std Date-std }             -- use this if you can
</pre></font>
Spec() can also be called as a global function, in which
case it can take the ASN.1 type as a string:
<font color="brown"><pre>
>>> ncbi.Spec('Date-std')
Date-std ::= SEQUENCE {        -- NOTE: this is NOT a unix tm struct
    year INTEGER ,             -- full year (including 1900)
    month INTEGER OPTIONAL ,   -- month (1-12)
    day INTEGER OPTIONAL ,     -- day of month (1-31)
    season VisibleString OPTIONAL ,  -- for "spring", "may-june", etc
    hour INTEGER OPTIONAL ,    -- hour of day (0-23)
    minute INTEGER OPTIONAL ,  -- minute of hour (0-59)
    second INTEGER OPTIONAL }  -- second of minute (0-59)
</pre></font>
Giving <code>Spec</code> an additional argument
that evaluates to "true" 
(e.g., <code>d.Spec(1)</code>, <code>ncbi.Spec('Date-std', True)</code>)
will make it bring up a web page with the specification.
These web pages contain various links that make it
easy to navigate ASN.1 specifications.

<p>
The fields of the object can be accessed using GetXyz, SetXyz,
ResetXyz, IsSetXyz, and CanGetXyz methods, where Xyz comes
from the name of the field:

<font color="brown"><pre>
>>> d.GetStd().GetYear()
2007
>>> d.SetStd().SetMonth(3)
>>> d.SetStd().SetDay(15)
>>> d.GetStd().IsSetMinute()
1
>>> d.SetStd().ResetMinute()
>>> d.GetStd().IsSetMinute()
0
>>> d.SetStd().ResetSecond()
>>> d.SetStd().SetSeason('Winter')
>>> print d.Asn()
Date ::= std {
  year 2007,
  month 3,
  day 15,
  season "Winter",
  hour 11
}
</pre></font>

<p>
<!-- Begin footer content -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT>
<a NAME="copyright"></a>
<address>
<a href="mailto:jcherry@ncbi.nlm.nih.gov">Josh Cherry</a>&nbsp;</address>
</td>

<td>


</tr>
</table>
